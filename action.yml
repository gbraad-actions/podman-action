name: 'Podman Action'
description: 'Run commands in any container environment using Podman'
inputs:
  image:
    description: 'Container image to use (e.g., fedora:latest, ubuntu:22.04, etc.)'
    required: true
    default: 'fedora:latest'
  run:
    description: 'Shell command to execute in the container'
    required: false
  working-directory:
    description: 'Working directory where commands will be executed'
    required: false
    default: '.'
  entrypoint:
    description: 'Override the default entrypoint of the container image'
    required: false
    default: ''
  podman-args:
    description: 'Additional arguments to pass to podman run command'
    required: false
outputs:
  stdout:
    description: 'Standard output of the command'
  exit-code:
    description: 'Exit code of the command'
runs:
  using: 'composite'
  steps:
    - name: Run in Podman Container
      shell: bash
      run: |
        # Set up variables
        IMAGE="${{ inputs.image }}"
        ENTRYPOINT="${{ inputs.entrypoint }}"
        PODMAN_ARGS="${{ inputs.podman-args }}"
        WORKING_DIR="${{ inputs.working-directory }}"
        RUN_COMMAND="${{ inputs.run }}"
        
        # Create temporary file for output capture
        STDOUT_FILE=$(mktemp)
        
        # Handle entrypoint override
        ENTRYPOINT_ARGS=""
        if [ ! -z "$ENTRYPOINT" ]; then
          ENTRYPOINT_ARGS="--entrypoint $ENTRYPOINT"
        fi
        
        # Process the command properly based on whether entrypoint is used
        if [ ! -z "$ENTRYPOINT" ]; then
          # When using custom entrypoint, don't convert newlines to semicolons
          # Instead, create a temp script and mount it
          TEMP_SCRIPT=$(mktemp)
          echo "$RUN_COMMAND" > "$TEMP_SCRIPT"
          chmod +x "$TEMP_SCRIPT"
          COMMAND_ARG="-c \"$(cat $TEMP_SCRIPT | tr '\n' ' ')\""
        else
          # Without entrypoint, keep original conversion
          # Replace newlines with semicolons for proper command execution
          COMMAND=$(echo "$RUN_COMMAND" | tr '\n' ';')
        fi
        
        echo "Running command in container..."
        echo "Image: $IMAGE"
        echo "Working directory: $WORKING_DIR"
        if [ ! -z "$ENTRYPOINT" ]; then
          echo "Entrypoint: $ENTRYPOINT"
        fi
        
        if [ ! -z "$ENTRYPOINT" ]; then
          CMD="podman run --rm -v ${{ github.workspace }}:${{ github.workspace }} -w ${{ github.workspace }}/$WORKING_DIR $PODMAN_ARGS $ENTRYPOINT_ARGS $IMAGE $COMMAND_ARG"
        else
          CMD="podman run --rm -v ${{ github.workspace }}:${{ github.workspace }} -w ${{ github.workspace }}/$WORKING_DIR $PODMAN_ARGS $IMAGE $COMMAND"
        fi
        
        echo "Executing: $CMD"
        
        # Execute the command using eval to preserve quotes
        eval $CMD | tee $STDOUT_FILE
        
        EXIT_CODE=${PIPESTATUS[0]}
        
        # Clean up
        if [ ! -z "$ENTRYPOINT" ]; then
          rm -f "$TEMP_SCRIPT"
        fi
        
        # Set outputs
        echo "exit-code=$EXIT_CODE" >> $GITHUB_OUTPUT
        
        echo "stdout<<EOF" >> $GITHUB_OUTPUT
        cat $STDOUT_FILE >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Clean up
        rm -f $STDOUT_FILE
        
        # Return appropriate exit code
        if [ "$EXIT_CODE" != "0" ]; then
          echo "Command failed with exit code $EXIT_CODE"
          exit $EXIT_CODE
        fi
